# vim: set expandtab shiftwidth=2 tabstop=8 textwidth=0:

# This template will create a fedora image based on the following variables:
#
#  - FEDORA_VERSION: the fedora version (28, 29, rawhide, etc...)
#  - FEDORA_RPMS:    if set, list of packages that needs to be installed
#  - FEDORA_EXEC:    if set, this command will be run once the packages have
#                    been installed
#  - UPSTREAM_REPO:  the upstream project on this gitlab instance where we might
#                    find the given tag (for example: `wayland/weston`)
#  - FEDORA_TAG:     tag to copy the image from the upstream registry. If the
#                    tag does not exist, create a new build and tag it
#
# The resulting image will be pushed in the local registry, under:
#     $CI_REGISTRY_IMAGE/fedora/$FEDORA_VERSION:$FEDORA_TAG
#
# Two flavors of templates are available:
#   - `.fedora@container-build`: this will force rebuild a new container
#     and tag it with $FEDORA_TAG without checks
#   - `.fedora@container-ifnot-exists`: this will rebuild a new container
#     only if $FEDORA is not available in the local registry or
#     in the $UPSTREAM_REPO registry

# we can not reuse exported variables in after_script,
# so have a common definition
.fedora_vars: &distro_vars |
        # exporting templates variables
        # https://gitlab.com/gitlab-com/support-forum/issues/4349
        export BUILDAH_FORMAT=docker
        export DISTRO=fedora
        export DISTRO_TAG=$FEDORA_TAG
        export DISTRO_VERSION=$FEDORA_VERSION
        export DISTRO_EXEC=$FEDORA_EXEC
        export BUILDAH_RUN="buildah run --isolation chroot"
        export BUILDAH_COMMIT="buildah commit --format docker"


# Do not use this template directly, you can not reuse the produced image
# as it is tagged with $CI_JOB_ID
..fedora@container-template:
  image: $CI_REGISTRY/wayland/ci-templates/buildah:latest
  stage: build
  before_script:
    # log in to the registry
    - podman login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

    - *distro_vars

  script:
  - *distro_vars
  - echo Building $DISTRO/$DISTRO_VERSION:$DISTRO_TAG from $DISTRO:$DISTRO_VERSION
    # initial set up: take the base image, update it and install the packages
  - buildcntr=$(buildah from $DISTRO:$DISTRO_VERSION)
  - buildmnt=$(buildah mount $buildcntr)
  - $BUILDAH_RUN $buildcntr dnf upgrade -y
  - if [[ x"$FEDORA_RPMS" != x"" ]] ;
    then
      $BUILDAH_RUN $buildcntr dnf install -y $FEDORA_RPMS ;
    fi

    # check if there is an optional post install script and run it
  - if [[ x"$DISTRO_EXEC" != x"" ]] ;
    then
      echo Running $DISTRO_EXEC ;
      set -x ;
      mkdir $buildmnt/tmp/clone ;
      pushd $buildmnt/tmp/clone ;
      git init ;
      git remote add origin $CI_REPOSITORY_URL ;
      git fetch --depth 1 origin $CI_COMMIT_SHA ;
      git checkout FETCH_HEAD  > /dev/null;
      buildah config --workingdir /tmp/clone $buildcntr ;
      $BUILDAH_RUN $buildcntr bash -c "set -x ; $DISTRO_EXEC" ;
      popd ;
      rm -rf $buildmnt/tmp/clone ;
      set +x ;
    fi

    # do not store the packages database, it's pointless
  - $BUILDAH_RUN $buildcntr dnf clean all

    # set up the working directory
  - buildah config --workingdir /app $buildcntr
    # umount the container, not required, but, heh
  - buildah unmount $buildcntr
    # tag the current container
  - $BUILDAH_COMMIT $buildcntr $CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID
    # clean up the working container
  - buildah rm $buildcntr

    # push the container image to the registry
    # There is a bug when pushing 2 tags in the same repo with the same base:
    # this may fail. Just retry it after.
  - podman push $CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID || true
  - sleep 2
  - podman push $CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID

    # mark the current stage as successed, to get the result in after_script
  - touch .success


..fedora@qemu-template:
  extends: ..fedora@container-template
  tags:
    - kvm
  image: $CI_REGISTRY/wayland/ci-templates/qemu-mkosi-base:latest
  script:
  - *distro_vars

  # start our current base Cloud image
  - /bin/bash /app/start_vm.sh -cdrom /app/my-seed.iso

  # install mkosi dependencies to build up our final VM image
  - ssh cloud@localhost -p 5555 sudo dnf install -y mkosi systemd-container

  # use the upstream mkosi code, to force keeping this particular release
  - ssh cloud@localhost -p 5555 git clone -b v5 https://github.com/systemd/mkosi.git

  - |
    cat <<EOF > mkosi.default
    [Distribution]
    Distribution=fedora
    Release=$FEDORA_VERSION

    [Output]
    Format=gpt_ext4
    Bootable=yes
    BootProtocols=bios
    Password=root
    KernelCommandLine=!* selinux=0 audit=0 rw console=tty0 console=ttyS0

    [Partitions]
    RootSize=2G

    [Packages]
    # The packages to appear in both the build and the final image
    Packages=
      openssh-clients
      openssh-server
      NetworkManager
      iproute
      iputils
      git-core
    EOF
  - echo $FEDORA_RPMS | tr ' ' '\n' | sed -e 's/^/  /' >> mkosi.default

  # send the mkosi file to the VM
  - scp -P 5555 mkosi.default cloud@localhost:mkosi.default

  # create a cache folder (useful only when manually testing this script)
  - ssh cloud@localhost -p 5555 mkdir mkosi.cache

  # mkosi 5 doesn't honor Password from the configuration file
  - ssh cloud@localhost -p 5555 sudo mkosi/mkosi --password root

  # fetch the images
  - scp -P 5555 cloud@localhost:image.raw dest-image.raw

  # mount the root partition locally to extract the kernel and initramfs
  - ssh cloud@localhost -p 5555 mkdir loop
  - offset=$(fdisk -l dest-image.raw | grep image.raw2 | cut -d ' ' -f 3)
  - ssh cloud@localhost -p 5555 sudo mount -o ro,loop,offset=$(($offset * 512)) image.raw loop/
  - ssh cloud@localhost -p 5555 sudo cp loop/boot/vmlinuz* loop/boot/initramfs* .
  - ssh cloud@localhost -p 5555 sudo umount loop/
  - ssh cloud@localhost -p 5555 sudo chown cloud vmlinuz* initramfs*

  - scp -P 5555 cloud@localhost:vmlinuz* .
  - scp -P 5555 cloud@localhost:initramfs* .

  # terminate qemu
  - kill $(pgrep qemu)

  # we did not tell mkosi to compress the image, we wanted to extract first
  # the kernel and initrd
  - xz dest-image.raw

  - echo Building $DISTRO/$DISTRO_VERSION:$DISTRO_TAG from $DISTRO:$DISTRO_VERSION

  - QEMU_BASE_IMAGE=${QEMU_BASE_IMAGE:-$CI_REGISTRY/wayland/ci-templates/qemu:latest}

  - buildcntr=$(buildah from $QEMU_BASE_IMAGE)
  - buildmnt=$(buildah mount $buildcntr)

  # insert our final VM image we just built
  - mkdir -p $buildmnt/app
  - mv dest-image.raw.xz $buildmnt/app/image.raw.xz
  - mv vmlinuz* initramfs-* $buildmnt/app/

  - |
    cat > $buildmnt/app/start_vm_kernel.sh <<EOF
    #!/bin/bash

    set -x

    KERNEL=\$1
    shift

    set -e

    if [[ x"\$KERNEL" == x"" ]]
    then
      KERNEL=\$(ls /app/vmlinuz* | sort | tail -1)
    fi

    INITRD=\$(ls /app/initram* | sort | tail -1)

    bash /app/start_vm.sh -kernel \$KERNEL \\
                          -initrd \$INITRD \\
                          -append "root=/dev/sda2 selinux=0 audit=0 rw console=tty0 console=ttyS0" \\
                          "\$@"

    EOF
  - chmod +x $buildmnt/app/start_vm_kernel.sh

    # umount the container, not required, but, heh
  - buildah unmount $buildcntr
    # tag the current container
  - $BUILDAH_COMMIT $buildcntr $CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID
    # clean up the working container
  - buildah rm $buildcntr

    # push the container image to the registry
    # There is a bug when pushing 2 tags in the same repo with the same base:
    # this may fail. Just retry it after.
  - podman push $CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID || true
  - sleep 2
  - podman push $CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID

    # mark the current stage as successed, to get the result in after_script
  - touch .success


.after_script_template: &after_script_template
  after_script:
    # if we did not build, or if there was a failure, exit
    # (the exit status does not matter here)
    - if [[ ! -e .success ]] ;
      then
        exit 0;
      fi

    - *distro_vars

    - skopeo copy docker://$CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$CI_JOB_ID
                  docker://$CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$DISTRO_TAG


.fedora@container-build:
  extends: ..fedora@container-template
  <<: *after_script_template


.fedora@container-build@arm64v8:
  extends: .fedora@container-build
  image: $CI_REGISTRY/wayland/ci-templates/arm64v8/buildah:latest
  tags:
    - aarch64


.fedora@qemu-build:
  extends: ..fedora@qemu-template
  <<: *after_script_template


.before_script_ifnot_exists: &before_script_ifnot_exists
  before_script:
    # log in to the registry
    - podman login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

    - *distro_vars

    # check if our image is already in the current registry
    - skopeo inspect docker://$CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$DISTRO_TAG > /dev/null && exit 0 || true

    # copy the original image into the current project registry namespace
    - skopeo copy docker://$CI_REGISTRY/$UPSTREAM_REPO/$DISTRO/$DISTRO_VERSION:$DISTRO_TAG
                  docker://$CI_REGISTRY_IMAGE/$DISTRO/$DISTRO_VERSION:$DISTRO_TAG && exit 0 || true


.fedora@container-ifnot-exists:
  extends: .fedora@container-build
  <<: *before_script_ifnot_exists


.fedora@container-ifnot-exists@arm64v8:
  extends: .fedora@container-ifnot-exists
  image: $CI_REGISTRY/wayland/ci-templates/arm64v8/buildah:latest
  tags:
    - aarch64


.fedora@qemu-ifnot-exists:
  extends: .fedora@qemu-build
  <<: *before_script_ifnot_exists
